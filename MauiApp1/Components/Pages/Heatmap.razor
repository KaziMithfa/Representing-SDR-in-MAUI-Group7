@page "/heatmap"
@using MauiApp1.Services
@inject CsvDataService CsvDataService
@inject IJSRuntime JSRuntime

<style>
    .scrollable-svg-container {
        width: 100%;
        height: 100%;
        overflow: auto;
        border: 1px solid #ccc;
    }
</style>

<EditForm Model="@heatmapInputModel" OnValidSubmit="HandleValidSubmit">
    <div class="form-container">
        <div class="form-column">
            <div class="form-row">
                <InputRadioGroup @bind-Value="heatmapInputModel.UseFileInput">
                    <InputRadio Value="true" /> <label>Upload CSV File</label>
                    <InputRadio Value="false" /> <label>Input CSV Content Directly</label>
                </InputRadioGroup>
            </div>

            @if (heatmapInputModel.UseFileInput)
            {
                <div class="form-row">
                    <label>CSV File:</label>
                    <InputFile OnChange="HandleFileSelected" accept=".csv" />
                </div>
            }
            else
            {
                <div class="form-row">
                    <label>CSV Content:</label>
                    <InputTextArea @bind-Value="heatmapInputModel.CsvContent" class="form-control" rows="10" />
                </div>
            }

            <div class="form-row">
                <label>Highlight Touch:</label>
                <InputNumber @bind-Value="heatmapInputModel.HighlightTouch" class="form-control" />
            </div>
            <div class="form-row">
                <label>Figure Name:</label>
                <InputText @bind-Value="heatmapInputModel.FigureName" class="form-control" />
            </div>
        </div>
        <div class="form-column">
            <div class="form-row">
                <label>X Axis Title:</label>
                <InputText @bind-Value="heatmapInputModel.XAxisTitle" class="form-control" />
            </div>
            <div class="form-row">
                <label>Y Axis Title:</label>
                <InputText @bind-Value="heatmapInputModel.YAxisTitle" class="form-control" />
            </div>
            <div class="form-row">
                <label>Chart Orientation:</label>
                <InputSelect @bind-Value="heatmapInputModel.IsHorizontal" class="form-control">
                    <option value="true">Horizontal</option>
                    <option value="false">Vertical</option>
                </InputSelect>
            </div>
        </div>
        <div class="form-column">
            <div class="form-row">
                <label>Max Cycles:</label>
                <InputNumber @bind-Value="heatmapInputModel.MaxCycles" class="form-control" />
            </div>
        </div>
    </div>

    <button type="submit" class="btn btn-primary">Generate Chart</button>
</EditForm>

<button @onclick="DownloadSVG">Download SVG</button>

<div class="scrollable-svg-container">
    <svg id="heatmapSvg" width="@chartWidth" height="@chartHeight" style="border: 1px solid;">
        @if (activeCellsColumn != null && activeCellsColumn.Any())
        {
            <text>
                <text x="@((chartWidth / 2))" y="@(30)" text-anchor="middle" font-size="16">@figureName</text>
            </text>
            @if (isHorizontal)
            {
                @for (int rowIndex = 0; rowIndex < numTouches; rowIndex++)
                {
                    var yPos = chartHeight - (rowIndex * (cellHeight + cellPadding)) - chartPadding;
                    foreach (var cell in activeCellsColumn[rowIndex])
                    {
                        var xPos = ((cell - minCell + 1) * (cellWidth + cellPadding)) + chartPadding - 50; // Offset for axis labels
                        <rect x="@xPos" y="@yPos" width="@cellWidth" height="@cellHeight" fill="@GetCellColor(rowIndex)" />
                        if (rowIndex == highlightTouch)
                        {
                            <rect x="@chartPadding" y="@yPos" width="@chartWidth - (2*chartPadding)" height="@cellHeight" fill="rgba(255, 0, 0, 0.5)" />
                        }
                    }
                }
                <line x1="@(chartPadding-30)" y1="30" x2="@(chartPadding-30)" y2="@(chartHeight - chartPadding + 30)" stroke="black" />
                <line x1="@(chartPadding-30)" y1="@(chartHeight - chartPadding + 30)" x2="@(chartWidth - chartPadding + 50)" y2="@(chartHeight - chartPadding + 30)" stroke="black" />


                @foreach (var label in GenerateAxisLabelsVertical(isHorizontal ? minTouch : minCell,
               isHorizontal ? maxTouch : maxCell, true))
                {
                    <text>
                        <text x="@((chartPadding - 35))" y="@(chartHeight - chartPadding - label.pos + 17)" text-anchor="end" font-size="12">@label.label</text>
                    </text>
                }

                @foreach (var label in GenerateAxisLabelsVertical(isHorizontal ? minCell : minTouch,
               isHorizontal ? maxCell : maxTouch, false))
                {
                    <text>
                        <text x="@(label.pos + chartPadding - 35)" y="@(chartHeight - chartPadding + 45)" text-anchor="middle" font-size="12">@label.label</text>
                    </text>
                }
            }
            else
            {
                @for (int touchIndex = 0; touchIndex < numTouches; touchIndex++)
                {
                    var xPos = (touchIndex * (cellWidth + cellPadding)) + chartPadding;
                    foreach (var cell in activeCellsColumn[touchIndex])
                    {
                        var yPos = chartHeight - ((cell - minCell + 1) * (cellHeight + cellPadding)) - chartPadding;
                        <rect x="@xPos" y="@yPos" width="@cellWidth" height="@cellHeight" fill="@GetCellColor(touchIndex)" />
                        if (touchIndex == highlightTouch)
                        {
                            <rect x="@xPos" y="@chartPadding" width="@cellWidth" height="@chartHeight - (2*chartPadding)" fill="rgba(255, 0, 0, 0.5)" />
                        }
                    }
                }

                //y axis
                <line x1="@(chartPadding-30)" y1="30" x2="@(chartPadding-30)" y2="@(chartHeight - chartPadding + 30)" stroke="black" />
                //x axis
                <line x1="@(chartPadding-30)" y1="@(chartHeight - chartPadding + 30)" x2="@(chartWidth - chartPadding + 50)" y2="@(chartHeight - chartPadding + 30)" stroke="black" />


                //y axis label
                @foreach (var label in GenerateAxisLabels(isHorizontal ? minTouch : minCell,
               isHorizontal ? maxTouch : maxCell, true))
                {
                    <text>
                        <text x="@((chartPadding - 35))" y="@(chartHeight - chartPadding - label.pos)" text-anchor="end" font-size="12">@label.label</text>
                    </text>
                }

                //x axis label
                @foreach (var label in GenerateAxisLabels(isHorizontal ? minCell : minTouch,
               isHorizontal ? maxCell : maxTouch, false))
                {
                    <text>
                        <text x="@(label.pos + chartPadding - 35)" y="@(chartHeight - chartPadding + 45)" text-anchor="middle" font-size="12">@label.label</text>
                    </text>
                }
            }


            <text>
                <text x="@((chartWidth / 2))" y="@(chartHeight - 5)"
                      text-anchor="middle" font-size="14">@xAxisTitle</text>
            </text>

            <text>
                <text x="15" y="@((chartHeight / 2))"
                      transform="rotate(-90 15, @((chartHeight / 2)))"
                      text-anchor="middle" font-size="14">@yAxisTitle</text>
            </text>
        }
    </svg>
</div>

@code {
    private List<HashSet<int>> activeCellsColumn = new();
    private bool isHorizontal = false;
    private int numTouches;
    private int count;
    private int highlightTouch = 0;
    private string xAxisTitle = "X-Axis";
    private string yAxisTitle = "Y-Axis";
    private string figureName = "Activity Graph";

    private int maxCycles = 0;
    private int minCell = 0;
    private int maxCell = 100;
    private int minTouch = 0;
    private int maxTouch = 100;
    private const int cellWidth = 20;
    private const int cellHeight = 10;
    private const int cellPadding = 5;
    private int chartPadding = 110;
    private int chartWidth = 800;
    private int chartHeight = 600;
    private HeatmapInputModel heatmapInputModel = new HeatmapInputModel();


    private async Task HandleValidSubmit()
    {
        if (heatmapInputModel.UseFileInput && heatmapInputModel.CsvFile != null)
        {
            var maxFileSize = 1024 * 1024;
            var stream = heatmapInputModel.CsvFile.OpenReadStream(maxFileSize);
            var result = await CsvDataService.ReadDataFromCsvAsync(stream);
            activeCellsColumn = result.Item1;
        }
        else if (!heatmapInputModel.UseFileInput && !string.IsNullOrWhiteSpace(heatmapInputModel.CsvContent))
        {
            var result = CsvDataService.ReadDataFromCsvContent(heatmapInputModel.CsvContent);
            activeCellsColumn = result.Item1;
        }

        highlightTouch = heatmapInputModel.HighlightTouch - 1;
        figureName = heatmapInputModel.FigureName;
        xAxisTitle = heatmapInputModel.XAxisTitle;
        yAxisTitle = heatmapInputModel.YAxisTitle;
        isHorizontal = heatmapInputModel.IsHorizontal;
        numTouches = Math.Min(activeCellsColumn.Count, heatmapInputModel.MaxCycles.HasValue ?
            heatmapInputModel.MaxCycles.Value : 1000);
        count = 0;

        CalculateChartDimensions();
        StateHasChanged();
    }
    private async Task DownloadSVG()
    {
        await JSRuntime.InvokeVoidAsync("downloadFile", "heatmap.svg");
    }
    private void HandleFileSelected(InputFileChangeEventArgs e)
    {
        var file = e.File;
        if (file != null)
        {
            heatmapInputModel.CsvFile = file;
        }
    }

    private string GetCellColor(int rowIndex) => rowIndex == highlightTouch ? "red" : "lightblue";

    private void CalculateChartDimensions()
    {
        minCell = int.MaxValue;
        maxCell = int.MinValue;

        foreach (var column in activeCellsColumn)
        {
            if (column.Any())
            {
                int currentMin = column.Min();
                int currentMax = column.Max();

                if (currentMin < minCell)
                    minCell = currentMin;
                if (currentMax > maxCell)
                    maxCell = currentMax;
            }
        }

        if (minCell == int.MaxValue && maxCell == int.MinValue)
        {
            minCell = 0;
            maxCell = 0;
        }

        minTouch = 0;
        maxTouch = numTouches;

        if (isHorizontal)
        {
            int cellRangeSpan = activeCellsColumn.Max(col => col.Max()) + 1 - minCell;
            chartWidth = (cellRangeSpan * (cellWidth + cellPadding)) + chartPadding + 50;
            chartHeight = (numTouches * (cellHeight + cellPadding)) + chartPadding + 200;
        }
        else
        {
            int cellRangeSpan = activeCellsColumn.Max(col => col.Max()) + 1 - minCell;
            chartHeight = (cellRangeSpan * (cellHeight + cellPadding)) + chartPadding + 50;
            chartWidth = (numTouches * (cellWidth + cellPadding)) + chartPadding + 200;
        }
    }

    private IEnumerable<(string label, int pos)> GenerateAxisLabels(int min, int max, bool isVertical)
    {
        var labels = new List<(string label, int pos)>();
        int range = max - min;

        int step = Math.Max(1, range / 10);

        string label;
        int pos;

        for (int i = min; i <= max; i += step)
        {
            label = i.ToString();

            if (isVertical)
            {
                pos = Convert.ToInt32((float)(i - min) * (cellHeight + (cellPadding))) + 8;
            }
            else
            {
                pos = Convert.ToInt32((float)(i - min) * (cellWidth + (cellPadding))) + 20;
            }

            labels.Add((label, pos));
        }

        if (isVertical)
        {
            label = max.ToString();
            pos = Convert.ToInt32((float)(max - min) * (cellHeight + (cellPadding))) + 8;
            labels.Add((label, pos));
        }
        else
        {
            label = max.ToString();
            pos = Convert.ToInt32((float)(max - min) * (cellWidth + (cellPadding))) + 20;
            labels.Add((label, pos));
        }

        return labels;
    }

    private IEnumerable<(string label, int pos)> GenerateAxisLabelsVertical(int min, int max, bool isVertical)
    {
        var labels = new List<(string label, int pos)>();
        int range = max - min;

        // Dynamically adjust the label density based on the orientation and dimensions.
        int step = Math.Max(1, range / 10);

        string label;
        int pos;

        for (int i = min; i <= max; i += step)
        {
            label = i.ToString();

            if (isVertical)
            {
                pos = Convert.ToInt32((float)(i - min) * (cellHeight + (cellPadding))) + 8;
                //pos = Convert.ToInt32((((float)(i - min)) * cellHeight + (2 * cellPadding)));
            }
            else
            {
                pos = Convert.ToInt32((float)(i - min) * (cellWidth + (cellPadding))) + 20;
                //pos = Convert.ToInt32(((float)(i - min) / range) * cellWidth) + (2 * cellPadding);
            }

            labels.Add((label, pos));
        }

        //add max
        if (isVertical)
        {
            label = max.ToString();
            pos = Convert.ToInt32((float)(max - min) * (cellHeight + (cellPadding))) + 8;
            labels.Add((label, pos));
        }
        else
        {
            label = max.ToString();
            pos = Convert.ToInt32((float)(max - min) * (cellWidth + (cellPadding))) + 20;
            labels.Add((label, pos));
        }

        return labels;
    }
}

<script>
    function getSvgContent() {
        var svg = document.getElementById('heatmapSvg');
        return svg.outerHTML;
    }

    function downloadFile(fileName) {
        var content = getSvgContent();
        var blob = new Blob([content], { type: 'image/svg+xml;charset=utf-8' });
        var url = URL.createObjectURL(blob);

        var downloadLink = document.createElement("a");
        downloadLink.href = url;
        downloadLink.download = fileName;
        document.body.appendChild(downloadLink);
        downloadLink.click();
        document.body.removeChild(downloadLink);
        URL.revokeObjectURL(url);
    }
</script>
